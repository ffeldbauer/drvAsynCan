<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html xml:lang="en" xmlns="http://www.w3.org/1999/xhtml">
<head>
  <meta content="text/html; charset=UTF-8" http-equiv="Content-Type" />
  <title>drvAsynRPiCan</title>
</head>
<body>
  <div style="text-align: center">
    <h1>drvAsynRPiCan: Asynchronous Port Driver Support</h1>
    <h2>For Raspberry Pi CAN bus interface</h2>
    <p><span style="font-weight: bold; font-size: 14pt">Release 1-00</span></p>
    <p><span style="font-weight: bold; font-size: 14pt">Florian Feldbauer</span></p>
    <p><span style="font-weight: bold; font-size: 14pt">November , 2012</span></p>
  </div>
  <hr />
  <div style="text-align: center">
    <h2>Contents</h2>
  </div>
  <div>
    <a href="#DeviceSupport">Generic Device Support for EPICS records from AsynDriver</a><br />
    <a href="#drvAsynCan">drvAsynCan</a><br />
    <a href="#drvAsynIsegHv">drvAsynIsegHv</a><br />
    <a href="#drvAsynWienerVme">drvAsynWienerVme</a><br />
    <a href="#drvAsynTHMP">drvAsynTHMP</a><br />
    <a href="#drvAsynLedPulser">drvAsynLedPulser</a><br />
    <a href="#drvAsynTmcm142">drvAsynTmcm142</a><br />
    <a href="#install">Install and Build</a><br />

  </div>
  <hr />
  <div style="text-align: center">
    <h2 id="DeviceSupport">Generic Device Support for EPICS records from AsynDriver</h2>
  </div>
  <p>Generic device support is provided for standard EPICS records by the AsynDriver module.
     For the AsynPortDrivers defined in this package the following interfaces are used:<br/>
  <i>Extract from the <a href="http://www.aps.anl.gov/epics/modules/soft/asyn/R4-21/asynDriver.html#genericEpicsSupport">AsynDriver Documentation:</a></i></p>
  <ul>
    <li>devAsynInt32 - support for drivers that implement interface asynInt32</li>
    <li>devAsynUInt32Digital - support for drivers that implement interface asynUInt32Digital</li>
    <li>devAsynFloat64 - support for drivers that implement interface asynFloat64</li>
  </ul>
  <p>The support uses the following conventions for DTYP and INP. OUT fields are the same as INP.</p>
  <pre>  field(DTYP,"asynXXX")
  field(INP,"@asyn(portName,addr,timeout)drvParams")
   or
  field(INP,"@asynMask(portName,addr,mask,timeout)drvParams")</pre>
  <p>where
  <ul>
    <li>XXX - The name of the type of interface supported.
    <li>portName - The name of the port.
    <li>addr - The address. If addr is not specified the default is 0.
    <li>mask - This is for devAsynUInt32Digital. It is also used by devAsynInt32 to specify the number of
          bits of the hardware device for drivers that do not support getBounds().
    <li>timeout - The timeout value for asynUser.timeout. If not specified the default is 1.0.
    <li>drvParams - This is passed to the low level driver via the asynDrvUser interface.
  </ul>
  <p>For example:</p>
  <pre>  field(DTYP, "asynInt32")
  field(INP,  "@asyn(portA,0,.1)thisIsForDriver")</pre>
  <hr />
  <div style="text-align: center">
    <h2 id="drvAsynCan">drvAsynCan</h2>
  </div>
  <p>The drvAsynCan driver supports devices connected to the CAN interface.
     It does not provide an interface for accessing it directly from a record
     on the IOC. It is used as lower-level driver for the communication with
     the CAN interface itself.<br /><br />
     CAN interfaces are configured with the <tt>drvAsynCanConfigure</tt> command:</p>
  <pre>  drvAsynCanConfigure( "portName", "canName" )</pre>
  <p>where the arguments are:</p>
  <ul>
    <li>portName - The portName that is registered with asynManager.</li>
    <li>canName - The name of the local CAN interface (e.g. "/dev/can", "COM1").</li>
  </ul>
  <p><b>NOTE:</b> Building this module for linux-x86(_64) architectures requires the kernel module from
     <a href="http://www.peak-system.com/fileadmin/media/linux/index.htm">PEAK systems</a>.
     On linux-arm the kernel module provided in this package is needed.</p>
  <p>This driver uses asynOption to set the bitrate for CAN messages in bit/s or to add filters for received
    CAN frames.</p>
    <pre>  asynSetOption( "portName", addr, "key", "value" )</pre>
    <table border="1"><thead>
        <th>Key</th><th>Description</th>
        </thead>
      <tbody>
        <tr><td>bitrate</td><td>Change the bitrate of the CAN interface in bit/s<br/>
          Allowed values are: 5000, 10000, 20000, 50000, 100000, 125000, 250000, 500000, and 1000000
          </td></tr>
        <tr><td>addfilter</td><td>Add a filter for received CAN messages<br/>
          The value should be of form <tt>"FromID:ToID:MSGTYPE"</tt><br/>
          Only messages with <tt>FromID &le; message id &le; ToID</tt> and MSGTYPE will be accepted.<br />
          The CAN ids are in hexadecimal.<br/>
          Multiple filters can be applied at the same time.
          </td></tr>
        <tr><td>delfilter</td><td>Delete all filters for received CAN messages.<br/>
          The value string is not needed by this option.
          </td></tr>
      </tbody></table>
      <p>MSGTYPE is a 2 bit number. Bit 0 represents the IDE flag of the CAN frame, bit 1
        the RTR flag.<br/>The truth-table for this filtering is given below (1=Accepted):</p>
      <table border="1">
        <tr align="center" valign="middle"><td></td><td colspan="2">RTR_Filter = 1</td></td><td colspan="2">RTR_Filter = 0</td><td></td></tr>
        <tr align="center" valign="middle"><td rowspan="2">IDE_Filter = 1</td><td>0 </td><td> 1 </td><td> 1 </td><td> 1 </td><td> IDE_bit = 0</td></tr>
        <tr align="center" valign="middle"><td> 0 </td><td>  1 </td><td> 1 </td><td> 1 </td><td rowspan="2">IDE_bit = 1</td></tr>
      <tr align="center" valign="middle"><td rowspan="2">IDE_Filter = 0</td><td> 0 </td><td>  0 </td><td> 0  </td><td> 0 </td></tr>
      <tr align="center" valign="middle"><td>0  </td><td> 1  </td><td> 1 </td><td>  1</td><td> IDE_bit = 0</td></tr>
      <tr align="center" valign="middle"><td></td><td>RTR_bit = 0</td></td><td colspan="2">RTR_bit = 1</td><td>RTR_bit = 0</td><td></td></tr>
      </table>

  <hr />
  <div style="text-align: center">
    <h2 id="drvAsynIsegHv">drvAsynIsegHv</h2>
  </div>
  <p>The drvAsynIsegHv driver supports the ISEG EHS/EDS high voltage modules.
    It uses the drvAsynRPiCan driver as lower-level driver.
    Therefore the drvAsynRPiCan driver has to be configured before using this driver.
    <br /><br />
    A high voltage module is configured with the <tt>drvAsynIsegHvConfigure</tt> command:</p>
  <pre>  drvAsynIsegHvConfigure( "portName", "CANport", crate_id, module_id )</pre>
  <p>where the arguments are:</p>
  <ul>
    <li>portName - The portName that is registered with asynManager.</li>
    <li>CANport - The name of a previous configured drvAsynRPiCan/drvAsynPeakCan driver.</li>
    <li>crate_id - The unique id for the crate in which this modules is placed.<br />
      Allowed values are: 0-7</li>
    <li>module_id - The place of this module inside the crate.<br />
      Allowed values are: 0-7</li>
  </ul>
  <p>Accessing this driver from the IOC is done by the standard device support from asynDriver.
    The driver parameters (drvParams) are:</p>
  <table border="1">
    <thead><tr><th>Parameter</th><th>Type</th><th>Dir</th><th>Description</th></tr></thead>
    <tbody>
      <tr><td>ISEGHV_CHAN_STATUS       </td><td>asynUInt32Digital </td><td> r   </td><td> 16-bit status word of a channel </td></tr>
      <tr><td>ISEGHV_CHAN_EVENT_STATUS </td><td>asynUInt32Digital </td><td> r   </td><td> 16-bit event status word of a channel </td></tr>
      <tr><td>ISEGHV_CHAN_VMOM         </td><td>asynFloat64       </td><td> r   </td><td> measured voltage of a channel in V</td></tr>
      <tr><td>ISEGHV_CHAN_IMOM         </td><td>asynFloat64       </td><td> r   </td><td> measured current of a channel in &mu;A</td></tr>
      <tr><td>ISEGHV_CHAN_VSET         </td><td>asynFloat64       </td><td> r/w </td><td> setpoint for voltage of a channel in V</td></tr>
      <tr><td>ISEGHV_CHAN_ISET         </td><td>asynFloat64       </td><td> r/w </td><td> current limit of a channel in &mu;A</td></tr>
      
      <tr><td>ISEGHV_MOD_STATUS        </td><td>asynUInt32Digital </td><td> r   </td><td> 16-bit status word of the module </td></tr>
      <tr><td>ISEGHV_MOD_EVENT_STATUS  </td><td>asynUInt32Digital </td><td> r   </td><td> 16-bit event status word of the module </td></tr>
      <tr><td>ISEGHV_TEMPERATURE       </td><td>asynFloat64       </td><td> r   </td><td> measured temperature of the module in &deg;C</td></tr>
      <tr><td>ISEGHV_RAMPSPEED         </td><td>asynFloat64       </td><td> r/w </td><td> Ramp speed of the module in <i>%V</i><sub>O,max</sub><br/>maximum is 20%</td></tr>
      <tr><td>ISEGHV_CLEAR_EVENT_STATUS</td><td>asynInt32<sup>1</sup>         </td><td> r/w   </td><td> Clears the event status of the module and all channels</td></tr>
      
      <tr><td>ISEGHV_EMERGENCYOFF      </td><td>asynInt32<sup>1</sup>         </td><td> r/w   </td><td> Switch all channels of the module off w/o ramp</td></tr>
      <tr><td>ISEGHV_SWITCHONOFF       </td><td>asynUInt32Digital </td><td> r/w   </td><td> Switch all channels of the module on or off<br/>(Mask should be 1)</td></tr>
    </tbody>
  </table>
  <p>The ADDR parameter is used as channel number for the device (0-15).
    All module related parameters have ADDR = 0<sup>2</sup>.<br/>
    The TIMEOUT parameter is not really significant because this is a synchronous asyn port driver.</p>
  <p>An additional "global" driver can be used to switch on/off all channels of the whole CAN bus:
    <pre>  drvAsynIsegHvGlobalConfigure( "portName", "CANport" )</pre>
    This driver has only the parameters ISEGHV_EMERGENCYOFF and ISEGHV_SWITCHONOFF.</p>
  <hr />
  <div style="text-align: center">
    <h2 id="drvAsynWienerVme">drvAsynWienerVme</h2>
  </div>
  <p>The drvAsynWienerVme driver supports the Wiener VME crate remote control.
    It uses the drvAsynRPiCan driver as lower-level driver.
    Therefore the drvAsynRPiCan driver has to be configured before using this driver.
    <br /><br />
    A VME remote control is configured with the <tt>drvAsynWienerVmeConfigure</tt> command:</p>
  <pre>  drvAsynWienerVmeConfigure( "portName", "CANport", crate_id )</pre>
  <p>where the arguments are:</p>
  <ul>
    <li>portName - The portName that is registered with asynManager.</li>
    <li>CANport - The name of a previous configured drvAsynRPiCan/drvAsynPeakCan driver.</li>
    <li>crate_id - The unique id for the crate.<br />
      Allowed values are: 1-127</li>
  </ul>
  <p>Accessing this driver from the IOC is done by the standard device support from asynDriver.
    The driver parameters (drvParams) are:</p>

  <table border="1" rules="groups">
    <thead><tr><th>Parameter</th><th>Type</th><th>dir</th><th>Description</th></tr></thead>
    <tbody>
      <tr><td>WIENER_VME_STATUS0         </td><td> asynUInt32Digital </td><td>  r   </td><td> Statusbyte 0 of the crate</td></tr>
      <tr><td>WIENER_VME_STATUS1         </td><td> asynUInt32Digital </td><td>  r   </td><td> Statusbyte 1 of the crate</td></tr>
      <tr><td>WIENER_VME_STATUS2         </td><td> asynUInt32Digital </td><td>  r   </td><td> Under voltage error flags</td></tr>
      <tr><td>WIENER_VME_STATUS3         </td><td> asynUInt32Digital </td><td>  r   </td><td> Over voltage error flags</td></tr>
      <tr><td>WIENER_VME_STATUS4         </td><td> asynUInt32Digital </td><td>  r   </td><td> External temperature error flags</td></tr>
      <tr><td>WIENER_VME_STATUS5         </td><td> asynUInt32Digital </td><td>  r   </td><td> Over current error flags</td></tr>
      <tr><td>WIENER_VME_STATUS6         </td><td> asynUInt32Digital </td><td>  r   </td><td> OVP error flags</td></tr>
      <tr><td>WIENER_VME_STATUS7         </td><td> asynUInt32Digital </td><td>  r   </td><td> Power supply temperature error flags</td></tr>
      </tbody><tbody>
      <tr><td>WIENER_VME_VMOM0           </td><td> asynInt32 </td><td>          r   </td><td> Measured voltage channel 0 in V/100</td></tr>
      <tr><td>WIENER_VME_IMOM0           </td><td> asynInt32 </td><td>          r   </td><td> Measured current channel 0 in A/100</td></tr>
      <tr><td>WIENER_VME_VMOM4           </td><td> asynInt32 </td><td>          r   </td><td> Measured voltage channel 4 in V/100</td></tr>
      <tr><td>WIENER_VME_IMOM4           </td><td> asynInt32 </td><td>          r   </td><td> Measured current channel 4 in A/100</td></tr>

      </tbody><tbody>
      <tr><td>WIENER_VME_VMOM1           </td><td> asynInt32 </td><td>          r   </td><td> Measured voltage channel 1 in V/100</td></tr>
      <tr><td>WIENER_VME_IMOM1           </td><td> asynInt32 </td><td>          r   </td><td> Measured current channel 1 in A/100</td></tr>
      <tr><td>WIENER_VME_VMOM5           </td><td> asynInt32 </td><td>          r   </td><td> Measured voltage channel 5 in V/100</td></tr>
      <tr><td>WIENER_VME_IMOM5           </td><td> asynInt32 </td><td>          r   </td><td> Measured current channel 5 in A/100</td></tr>

      </tbody><tbody>
      <tr><td>WIENER_VME_VMOM2           </td><td> asynInt32 </td><td>          r   </td><td> Measured voltage channel 2 in V/100</td></tr>
      <tr><td>WIENER_VME_IMOM2           </td><td> asynInt32 </td><td>          r   </td><td> Measured current channel 2 in A/100</td></tr>
      <tr><td>WIENER_VME_VMOM6           </td><td> asynInt32 </td><td>          r   </td><td> Measured voltage channel 6 in V/100</td></tr>
      <tr><td>WIENER_VME_IMOM6           </td><td> asynInt32 </td><td>          r   </td><td> Measured current channel 6 in A/100</td></tr>

      </tbody><tbody>
      <tr><td>WIENER_VME_VMOM3           </td><td> asynInt32 </td><td>          r   </td><td> Measured voltage channel 3 in V/100</td></tr>
      <tr><td>WIENER_VME_IMOM3           </td><td> asynInt32 </td><td>          r   </td><td> Measured current channel 3 in A/100</td></tr>
      <tr><td>WIENER_VME_VMOM7           </td><td> asynInt32 </td><td>          r   </td><td> Measured voltage channel 7 in V/100</td></tr>
      <tr><td>WIENER_VME_IMOM7           </td><td> asynInt32 </td><td>          r   </td><td> Measured current channel 7 in A/100</td></tr> 

      </tbody><tbody>
      <tr><td>WIENER_VME_FANMIDDLE       </td><td> asynInt32 </td><td>          r   </td><td> Middle speed of all 6 fans in rps</td></tr>
      <tr><td>WIENER_VME_FANNOMINAL      </td><td> asynInt32 </td><td>          r   </td><td> Nominal speed of all 6 fans in rps</td></tr>
      <tr><td>WIENER_VME_FAN1            </td><td> asynInt32 </td><td>          r   </td><td> Speed of fan 1 in rps</td></tr>
      <tr><td>WIENER_VME_FAN2            </td><td> asynInt32 </td><td>          r   </td><td> Speed of fan 2 in rps</td></tr>
      <tr><td>WIENER_VME_FAN3            </td><td> asynInt32 </td><td>          r   </td><td> Speed of fan 3 in rps</td></tr>
      <tr><td>WIENER_VME_FAN4            </td><td> asynInt32 </td><td>          r   </td><td> Speed of fan 4 in rps</td></tr>
      <tr><td>WIENER_VME_FAN5            </td><td> asynInt32 </td><td>          r   </td><td> Speed of fan 5 in rps</td></tr>
      <tr><td>WIENER_VME_FAN6            </td><td> asynInt32 </td><td>          r   </td><td> Speed of fan 6 in rps</td></tr>

      </tbody><tbody>
      <tr><td>WIENER_VME_TEMP1           </td><td> asynInt32 </td><td>          r   </td><td> External temperature 1 in &deg;C</td></tr>
      <tr><td>WIENER_VME_TEMP2           </td><td> asynInt32 </td><td>          r   </td><td> External temperature 2 in &deg;C</td></tr>
      <tr><td>WIENER_VME_TEMP3           </td><td> asynInt32 </td><td>          r   </td><td> External temperature 3 in &deg;C</td></tr>
      <tr><td>WIENER_VME_TEMP4           </td><td> asynInt32 </td><td>          r   </td><td> External temperature 4 in &deg;C</td></tr>
      <tr><td>WIENER_VME_TEMP5           </td><td> asynInt32 </td><td>          r   </td><td> External temperature 5 in &deg;C</td></tr>
      <tr><td>WIENER_VME_TEMP6           </td><td> asynInt32 </td><td>          r   </td><td> External temperature 6 in &deg;C</td></tr>
      <tr><td>WIENER_VME_TEMP7           </td><td> asynInt32 </td><td>          r   </td><td> External temperature 7 in &deg;C</td></tr>
      <tr><td>WIENER_VME_TEMP8           </td><td> asynInt32 </td><td>          r   </td><td> External temperature 8 in &deg;C</td></tr>

      </tbody><tbody>
      <tr><td>WIENER_VME_SWITCHONOFF     </td><td> asynUInt32Digital </td><td>          r/w </td><td> Switch crate on/off<br/>(Mask should be 1)</td></tr> 
      </tbody><tbody>
      <tr><td>WIENER_VME_SYSRESET        </td><td> asynInt32<sup>1</sup> </td><td>          r/w   </td><td> Perform system reset</td></tr> 
      </tbody><tbody>
      <tr><td>WIENER_VME_FANSPEED        </td><td> asynInt32 </td><td>          r/w   </td><td> Change nominal speed of all 6 fans</td></tr>
    </tbody>
  </table>
  <p>The paramters are arranged in blocks. Each block is updated when the first paramter was read.
    The other paramters should be triggered using SCAN=''I/O INTR''.<br/>
    The VME crate doesn't use the ADDR parameter, therfore it is always 0.<br/>
  The TIMEOUT parameter is not really significant because this is a synchronous asyn port driver.</p>
  <hr />
  <div style="text-align: center">
    <h2 id="drvAsynTHMP">drvAsynTHMP</h2>
  </div>
  <p>The drvAsynTHMP driver supports the Temperature and Humidity Monitoring Board for PANDA (THMP).
    It uses the drvAsynRPiCan driver as lower-level driver.
    Therefore the drvAsynRPiCan driver has to be configured before using this driver.
    <br /><br />
    A THMP is configured with the <tt>drvAsynTHMPConfigure</tt> command:</p>
  <pre>  drvAsynTHMPConfigure( "portName", "CANport", can_id )</pre>
  <p>where the arguments are:</p>
  <ul>
    <li>portName - The portName that is registered with asynManager.</li>
    <li>CANport - The name of a previous configured drvAsynRPiCan/drvAsynPeakCan driver.</li>
    <li>can_id - The unique CAN id for this THMP.<br />
      Allowed values are: 0x700-0x7ff</li>
  </ul>
  <p>Accessing this driver from the IOC is done by the standard device support from asynDriver.
    The driver parameters (drvParams) are:</p>
  <table border="1">
    <thead><tr><th>Parameter</th><th>Type</th><th>Dir</th><th>Description</th></tr></thead>
    <tbody>
      <tr><td>THMP_RAWVALUE </td><td>asynInt32 </td><td> r   </td><td>ADC conversion result for one read-out channel </td></tr>
      <tr><td>THMP_IOBOARD </td><td>asynUInt32Digital </td><td> r/w </td><td>16-bit value for one I/O board </td></tr>
      <tr><td>THMP_SERIALS </td><td>asynUInt32Digital </td><td> r </td><td>2*3-byte unique serial id of the 8 piggyback boards an the mainboard</td></tr>
      <tr><td>THMP_FIRMWARE </td><td>asynUInt32Digital </td><td> r </td><td>16-bit firmware code</td></tr>
      <tr><td>THMP_ERROR </td><td>asynUInt32Digital </td><td> r </td><td>16-bit error message from THMP</td></tr>
      <tr><td>THMP_CONFIG_IO </td><td>asynInt32 </td><td> r/w </td><td>8-bit I<sup>2</sup>C-Address offset for one I/O board</td></tr>
      <tr><td>THMP_TRG_ADC </td><td>asynInt32<sup>1</sup> </td><td> r/w </td><td>Trigger read-out of ADC conversion results</td></tr>
      <tr><td>THMP_TRG_IO </td><td>asynInt32<sup>1</sup> </td><td> r/w </td><td>Trigger read-out of I/O boards</td></tr>
      <tr><td>THMP_TRG_SERIALS </td><td>asynInt32<sup>1</sup> </td><td> r/w </td><td>Trigger read-out of serial ids</td></tr>
    </tbody>
  </table>
  <p>The ADDR parameter is used as channel number for the device<sup>2</sup>:</p>
  <ul>
    <li>THMP_RAWVALUE supports ADDR = 0-63</li>
    <li>THMP_SERIALS supports ADDR = 0-17 (0-8: higher 3 bytes of serials; 9-17: lower 3 bytes of serials)</li> 
    <li>THMP_CONFIG_IO and THMP_IOBOARD support ADDR = 0,1</li>
  </ul>

  <hr />
  <div style="text-align: center">
    <h2 id="drvAsynLedPulser">drvAsynLedPulser</h2>
  </div>
  <p>The drvAsynLedPulser driver supports the LED Pulser used by the EMC group of the PANDA collaboration.
    It uses the drvAsynRPiCan driver as lower-level driver.
    Therefore the drvAsynRPiCan driver has to be configured before using this driver.
    <br /><br />
    A LED Pulser is configured with the <tt>drvAsynLedPulserConfigure</tt> command:</p>
  <pre>  drvAsynLedPulserConfigure( "portName", "CANport", can_id, "filename" )</pre>
  <p>where the arguments are:</p>
  <ul>
    <li>portName - The portName that is registered with asynManager.</li>
    <li>CANport - The name of a previous configured drvAsynRPiCan/drvAsynPeakCan driver.</li>
    <li>can_id - The unique CAN Bus id of this LED Pulser.<br />
      Allowed values are: 0x600-0x6ff</li>
    <li>filename - The name of the file containing calibration parameters for intensity settings.<br/>
    This file must be a plain text file containing a list of pairs of the parameters: "<tt>DAC-value Intensity[%]</tt>"</li>
  </ul>
  <p>Accessing this driver from the IOC is done by the standard device support from asynDriver.
    The driver parameters (drvParams) are:</p>
  <table border="1">
    <thead><tr><th>Parameter</th><th>Type</th><th>Dir</th><th>Description</th></tr></thead>
    <tbody>
      <tr><td>LEDPULSER_INTENSITY  </td><td>asynFloat64 </td><td> r/w  </td><td> Intensity of the LED pulser in % </td></tr>
      <tr><td>LEDPULSER_FREQUENCY  </td><td>asynFloat64 </td><td> r/w  </td><td> Frequency of the LED pulser in kHz<br/>
                                                                                 (Allowed values 0-500)</td></tr>
      <tr><td>LEDPULSER_CYCLES     </td><td>asynInt32   </td><td> r/w  </td><td> Number of cycles<br/> 
                                                                                 (Allowed values 0-65525; 65525=continous)</td></tr>
      <tr><td>LEDPULSER_TRG_MODE   </td><td>asynUInt32Digital   </td><td> r/w  </td><td> Trigger Mode (internal/external)<br/>
                                                                                 (Mask should be 1)</td></tr>
      <tr><td>LEDPULSER_COLOR      </td><td>asynUInt32Digital   </td><td> r/w  </td><td> Which LED is triggered (blue, green, red, off) <br/>
                                                                                 (Mask should be 3)</td></tr>
      <tr><td>LEDPULSER_WRITE      </td><td>asynInt32<sup>1</sup>   </td><td> r/w  </td><td> Send all parameters to LED Pulser </td></tr>
      <tr><td>LEDPULSER_READ       </td><td>asynInt32<sup>1</sup>   </td><td> r/w  </td><td> Read all parameters from LED Pulser </td></tr>
    </tbody>
  </table>
  <p>The LED Pulser doesn't use the ADDR parameter, therfore it is always 0.<br/>
    The TIMEOUT parameter is not really significant because this is a synchronous asyn port driver.</p>

  <hr />
  <div style="text-align: center">
    <h2 id="drvAsynTmcm142">drvAsynTmcm142</h2>
  </div>
  <p>The drvAsynTmcm142 driver supports the TMCM142 1-axis stepper controller/driver.
    It uses the drvAsynRPiCan driver as lower-level driver.
    Therefore the drvAsynRPiCan driver has to be configured before using this driver.
    <br /><br />
    A TMCM142 controller is configured with the <tt>drvAsynTmcm142Configure</tt> command:</p>
  <pre>  drvAsynLedPulserConfigure( "portName", "CanPort", can_id_w, can_id_r )</pre>
  <p>where the arguments are:</p>
  <ul>
    <li>portName - The portName that is registered with asynManager.</li>
    <li>CanPort - The name of a previous configured drvAsynRPiCan/drvAsynPeakCan driver.</li>
    <li>can_id_w - The unique CAN Bus id of this motor driver.</li>
    <li>can_id_r - The unique CAN Bus id of this motor driver used for replies.</li>
  </ul>
  <p>Accessing this driver from the IOC is done by the standard device support from asynDriver.
    All parameters are of type asynInt32. For parameter names the Mnemonic commands of the controller
    prepended with 'TMCM142_' are used.
    The address parameter from AsynDriver is used to code the <i>type</i> inside the command.
    Bank/Motor id is currently hard coded as 0.<br />
    For additional information refer to the <a href="http://www.mocontronic.de/files/TMCM-142_TMCL_firmware_manual.pdf">TMCL Firmware Manual</a></p>

  <hr />
  <div style="text-align: center">
    <h2 id="install">Install and Build</h2>
  </div>
  <p>After obtaining a copy of the distribution, it must be installed and built for use
    at your site. Therefore you have to follow these steps:</p>
  <ol>
    <li>Download and build <a href="http://www.aps.anl.gov/epics/" target="new">EPICS base</a> (3.14.12.2 or newer)
      and the <a target="new" href="http://www.aps.anl.gov/epics/modules/soft/asyn/">AsynDriver module</a> (4-21 or newer)</li>
    <li>Change path to AsynDriver and EPICS base in drvAsynCan/configure/RELEASE</li>
    <li>Build the module</li>
  </ol>
  <p>Building this module for linux-x86(_64) architectures requires the kernel module from
    <a href="http://www.peak-system.com/fileadmin/media/linux/index.htm">PEAK systems</a>.
    On linux-arm the kernel module provided in this package is needed.</p>
<hr/>
<p><span style="font-size: 8pt">1: These parameters are used as command, which means the value of these
   parameters will never change</span><br/>
   <span style="font-size: 8pt">2: Due to the internal structure of AsynPortDrivers all parameters exist
   for all addresses. Write methods for not used parameter address combinations simply return asynSuccess without
   performing any action. The values of these combinations will therefore always be 0</span></p>
</body>
</hmtl>
